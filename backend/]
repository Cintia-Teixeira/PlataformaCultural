module.exports = app => {
  const { existsOrError, notExistsOrError } = app.api.validation

  const save = async(req, res) => {
    let eventP = {...req.body }
    if (req.params.id) eventP.id = req.params.id
    

    existsOrError(eventP.title, "Título não informado")
    existsOrError(eventP.userId, "Usuário não informado")
    existsOrError(eventP.categoryId, "Categoria não informada")
    existsOrError(eventP.description, "descrição não informado")
    existsOrError(eventP.date, "data não informada")

    eventP.createAt = new Date()

    // Caso não exista Tags associadas 
    const promiseSearchTopic = () => {
      return app.db("eventPs").select().where({"id":topic.id}).then(
        eventPDB => {
          eventP = topicDB[0]
          console.log(eventP)
          promiseSearchTopicCategory()
        }
      )
    }


    const promiseSearchTopicCategory = () => {
      return app.db("eventPsCategories").select().where({"topicId":topic.id})
        .then(eventPCategoryDB => {
          eventP.categoriesTagged = topicCategoryDB
          res.json(eventP)
        }).catch( err => res.status(400).send(err) )
    }

    if(!eventP.categoriesTagged){
      eventP.categoriesTagged = [topic.topicCategory]
    }

    // Casos existam tags if (eventP.id) {
      //Flowchart Guarde as tags -> delete todas do banco -> atualize o eventP -> readicione as tags -> trate o json -> Envie o Json
   if(eventP.id) {
      let categoriesTagged = eventP.categoriesTagged
      delete eventP.categoriesTagged

      const promiseDeleteTopicCategories = () => {
        return app.db("eventPsCategories").where('topicId',topic.id).del()
          .then(
            resp => {
              promiseUpdateTopic()
            }
          )
      }

      const promiseUpdateTopic = () => {
        return app.db("eventPs").where("id", topic.id).update(topic)
          .then(resp => {
            console.log(resp)
            promiseInsertTopicCategory()
          })
      }

      const promiseInsertTopicCategory = () =>{

        let preQuerie = "INSERT INTO eventPsCategories(topicId, categoriesId) VALUES "
        categoriesTagged.forEach(category => {
          preQuerie = preQuerie.concat(`( ${eventP.id} , ${category}  ),`)
        })

        preQuerie = preQuerie.substring(0, preQuerie.length-1).concat(";")
        console.log(preQuerie)

        return app.db.raw(preQuerie).then(
          _ => promiseSearchTopic()
        )
      }


      promiseDeleteTopicCategories()

    } else {

      console.log(eventP)
      console.log( eventP.categoriesTagged )
      let categoriesTagged = eventP.categoriesTagged
      delete eventP.categoriesTagged

      const promiseInsertTopic = () => {
        return  app.db('eventPs').insert(topic).then(id => {
          eventP.id = id[0]
          console.log("eventP id = ", topic.id)
          console.log("id[0] =", id[0])
          promiseInsertTopicCategory()

        }).catch(err => {
          console.log(err)
        })
      }

      const promiseInsertTopicCategory = () =>{

        let preQuerie = "INSERT INTO eventPsCategories(topicId, categoriesId) VALUES "
        categoriesTagged.forEach(category => {
        preQuerie = preQuerie.concat(`( ${eventP.id} , ${category}  ),`)
      })

        preQuerie = preQuerie.substring(0, preQuerie.length-1).concat(";")
        console.log(preQuerie)

        return app.db.raw(preQuerie).then(
          _ => promiseSearchTopic()
        )
      }

      promiseInsertTopic()

    }
  }


  const getById = (req, res) => {
    let eventP = {}
    eventP.id = req.params.id

    const searchTopicsCategories = () =>{
     return app.db('eventPsCategories').select().where('topicId', topic.id)
        .then(resp => {
          eventP.categoriesTagged = resp
          res.json(eventP)
        }).catch(res.status(500).send(err))
    }

    const searchTopics = () => {
      return app.db('eventPs').select().where({ id: topic.id })
        .then(resp => {
          console.log(resp[0])
          eventP=resp[0]
          searchTopicsCategories()
        }).catch(res.status(500))
    }

    searchTopics()

  }

  let limit = 12
  const getMostRecent = (req, res) => {
    let page = parseInt( req.query.page ) || 0 
    const offset = (page) => {
      return page*limit
    }
    let settedOffset = offset(page) 
    console.log("set offset: ", settedOffset)
    preQuerie = `SELECT * FROM eventPs ORDER BY createAt DESC LIMIT ${settedOffset} , ${limit};`

    app.db.raw(preQuerie)
      .then(resp => {
        let data = {}
        data.page = page
        data.data = resp[0]
        console.log(data)
        res.json(data)
      }).catch(err => {
        res.status(500).send(err)
      })

  }

  const getMostReplyededs = (req, res) => {
    let page = parseInt( req.query.page ) || 0 
    const offset = (page) => {
      return page*limit
    }
    let settedOffset = offset(page) 
    console.log("set offset: ", settedOffset)
    preQuerie = `SELECT * FROM eventPs ORDER BY numerOfReplies DESC LIMIT ${settedOffset}, ${limit};`
    app.db.raw(preQuerie)
      .then(resp => {
        let data = {}
        data.page = page
        data.data = resp[0]
        console.log(data)
        res.json(data)
      }).catch(err => {
        res.status(500).send(err)
      })
  }

  return { save, getById, getMostRecent, getMostReplyededs }
}
